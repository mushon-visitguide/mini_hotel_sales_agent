"""
Conversation state management.

Maintains complete conversation state including:
- Booking context (dates, guests, preferences)
- Message history (user and assistant messages)
- Tool execution history (compressed summaries)
- Conversation metadata (turn counts, session info)
"""
import json
from pathlib import Path
from typing import Optional, List, Dict, Any
from datetime import datetime

from src.models.booking_context import BookingContext
from src.models.conversation import Message, MessageRole, ToolExecutionSummary, ConversationMetadata


class ConversationState:
    """
    Manages complete conversation state for a single session.

    This is the main state container that:
    1. Tracks booking information across turns
    2. Maintains message history with sliding window
    3. Stores compressed tool execution history
    4. Manages conversation metadata and persistence
    """

    def __init__(
        self,
        session_id: str,
        hotel_id: Optional[str] = None,
        pms_type: Optional[str] = None,
        phone_number: Optional[str] = None,
        host_guidance_prompt: Optional[str] = None,
        storage_dir: Optional[Path] = None
    ):
        """
        Initialize conversation state.

        Args:
            session_id: Unique session identifier
            hotel_id: Hotel ID for this conversation
            pms_type: PMS type (minihotel, ezgo)
            phone_number: Guest phone number for session authentication
            host_guidance_prompt: Hotel-specific guidance for response generation
            storage_dir: Directory for session persistence (default: storage/sessions/)
        """
        # Core state
        self.booking_context = BookingContext()
        self.messages: List[Message] = []
        self.tool_executions: List[ToolExecutionSummary] = []
        self.metadata = ConversationMetadata(
            session_id=session_id,
            hotel_id=hotel_id,
            pms_type=pms_type,
            phone_number=phone_number,
            host_guidance_prompt=host_guidance_prompt
        )

        # Conversation summary (generated by summarizer)
        self.conversation_summary: Optional[str] = None

        # Storage
        self.storage_dir = storage_dir or Path("storage/sessions")
        self.storage_dir.mkdir(parents=True, exist_ok=True)

    # === Message Management ===

    def add_user_message(self, content: str) -> None:
        """Add user message to history"""
        self.metadata.increment_turn()
        self.metadata.increment_messages()

        message = Message(
            role=MessageRole.USER,
            content=content,
            turn_number=self.metadata.total_turns
        )
        self.messages.append(message)

    def add_assistant_message(self, content: str) -> None:
        """Add assistant message to history"""
        self.metadata.increment_messages()

        message = Message(
            role=MessageRole.ASSISTANT,
            content=content,
            turn_number=self.metadata.total_turns
        )
        self.messages.append(message)

    def get_recent_messages(self, count: int = 5) -> List[Message]:
        """Get last N messages from history"""
        return self.messages[-count:] if self.messages else []

    def get_messages_since_turn(self, turn_number: int) -> List[Message]:
        """Get all messages since a specific turn (inclusive)"""
        return [msg for msg in self.messages if msg.turn_number and msg.turn_number >= turn_number]

    # === Tool Execution Management ===

    def add_tool_execution(
        self,
        tool_name: str,
        tool_id: str,
        inputs: Dict[str, Any],
        output_summary: str,
        output_metadata: Optional[Dict[str, Any]] = None,
        success: bool = True,
        error_message: Optional[str] = None
    ) -> None:
        """
        Add tool execution to history.

        Args:
            tool_name: Name of the tool (e.g., "pms.get_availability_and_pricing")
            tool_id: Unique ID for this execution (e.g., "get_availability_1")
            inputs: Input parameters passed to the tool
            output_summary: Compressed summary of tool output
            output_metadata: Key metadata extracted from output
            success: Whether tool executed successfully
            error_message: Error message if failed
        """
        self.metadata.increment_tool_executions()

        execution = ToolExecutionSummary(
            turn_number=self.metadata.total_turns,
            tool_name=tool_name,
            tool_id=tool_id,
            inputs=inputs,
            output_summary=output_summary,
            output_metadata=output_metadata,
            success=success,
            error_message=error_message
        )
        self.tool_executions.append(execution)

    def get_recent_tool_executions(self, count: int = 3) -> List[ToolExecutionSummary]:
        """Get last N tool executions"""
        return self.tool_executions[-count:] if self.tool_executions else []

    def get_tool_executions_by_name(self, tool_name: str, limit: int = 5) -> List[ToolExecutionSummary]:
        """Get recent executions of a specific tool"""
        matching = [t for t in self.tool_executions if t.tool_name == tool_name]
        return matching[-limit:] if matching else []

    def get_last_availability_check(self) -> Optional[ToolExecutionSummary]:
        """Get the most recent availability check"""
        for execution in reversed(self.tool_executions):
            if "availability" in execution.tool_name:
                return execution
        return None

    # === Booking Context Management ===

    def update_booking_context(self, slots: Dict[str, Any]) -> None:
        """Update booking context from extracted slots"""
        self.booking_context.update_from_slots(slots)

    def is_ready_for_booking(self) -> bool:
        """Check if we have all info needed for booking"""
        return self.booking_context.is_ready_for_booking()

    def get_missing_booking_info(self) -> List[str]:
        """Get list of missing required booking information"""
        return self.booking_context.missing_info()

    # === Summarization ===

    def should_summarize(self, summarize_every_n_turns: int = 5) -> bool:
        """
        Check if conversation should be summarized.

        Returns True if:
        - We have more than N turns since last summary
        - We have messages to summarize
        """
        turns_since_summary = self.metadata.total_turns - self.metadata.last_summarized_turn
        return turns_since_summary >= summarize_every_n_turns and len(self.messages) > 0

    def set_summary(self, summary: str) -> None:
        """
        Set conversation summary and mark as summarized.

        Args:
            summary: LLM-generated summary of conversation so far
        """
        self.conversation_summary = summary
        self.metadata.mark_summarized(self.metadata.total_turns)

    # === Context Building ===

    def build_context_prompt(
        self,
        include_recent_messages: int = 5,
        include_recent_tools: int = 3
    ) -> str:
        """
        Build context prompt for LLM with:
        - Conversation summary (if exists)
        - Recent tool executions
        - Recent messages
        - Current booking context

        This provides the LLM with necessary context while keeping it compact.
        """
        parts = []

        # 1. Conversation summary (if available)
        if self.conversation_summary:
            parts.append(f"## Previous Conversation Summary\n{self.conversation_summary}\n")

        # 2. Current booking context
        if self.booking_context.has_dates() or self.booking_context.selected_room_code:
            parts.append(f"## Current Booking Context\n{str(self.booking_context)}\n")

            # Add missing info if not ready
            if not self.is_ready_for_booking():
                missing = self.get_missing_booking_info()
                parts.append(f"Missing information: {', '.join(missing)}\n")

        # 3. Recent tool executions (for reference)
        recent_tools = self.get_recent_tool_executions(include_recent_tools)
        if recent_tools:
            parts.append("## Recent Tool Executions")
            for tool in recent_tools:
                status = "✓" if tool.success else "✗"
                parts.append(f"- [{status}] {tool.tool_id}: {tool.output_summary}")
            parts.append("")

        # 4. Recent messages (sliding window)
        recent_messages = self.get_recent_messages(include_recent_messages)
        if recent_messages:
            parts.append("## Recent Messages")
            for msg in recent_messages:
                parts.append(f"{msg.role.value}: {msg.content}")
            parts.append("")

        return "\n".join(parts)

    # === Persistence ===

    def save(self) -> None:
        """Save conversation state to disk"""
        file_path = self.storage_dir / f"{self.metadata.session_id}.json"

        state_dict = {
            "booking_context": self.booking_context.to_dict(),
            "messages": [msg.to_dict() for msg in self.messages],
            "tool_executions": [tool.to_dict() for tool in self.tool_executions],
            "metadata": self.metadata.to_dict(),
            "conversation_summary": self.conversation_summary
        }

        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(state_dict, f, indent=2, ensure_ascii=False, default=str)

    @classmethod
    def load(cls, session_id: str, storage_dir: Optional[Path] = None) -> Optional["ConversationState"]:
        """
        Load conversation state from disk.

        Args:
            session_id: Session ID to load
            storage_dir: Directory where sessions are stored

        Returns:
            ConversationState if found, None otherwise
        """
        storage_dir = storage_dir or Path("storage/sessions")
        file_path = storage_dir / f"{session_id}.json"

        if not file_path.exists():
            return None

        with open(file_path, 'r', encoding='utf-8') as f:
            state_dict = json.load(f)

        # Create state
        metadata = ConversationMetadata.from_dict(state_dict["metadata"])
        state = cls(
            session_id=session_id,
            hotel_id=metadata.hotel_id,
            pms_type=metadata.pms_type,
            storage_dir=storage_dir
        )

        # Restore data
        state.booking_context = BookingContext.from_dict(state_dict["booking_context"])
        state.messages = [Message.from_dict(msg) for msg in state_dict["messages"]]
        state.tool_executions = [
            ToolExecutionSummary.from_dict(tool) for tool in state_dict["tool_executions"]
        ]
        state.metadata = metadata
        state.conversation_summary = state_dict.get("conversation_summary")

        return state

    @classmethod
    def create_or_load(
        cls,
        session_id: str,
        hotel_id: Optional[str] = None,
        pms_type: Optional[str] = None,
        phone_number: Optional[str] = None,
        host_guidance_prompt: Optional[str] = None,
        storage_dir: Optional[Path] = None
    ) -> "ConversationState":
        """
        Create new state or load existing one.

        Args:
            session_id: Session ID
            hotel_id: Hotel ID (for new sessions)
            pms_type: PMS type (for new sessions)
            phone_number: Guest phone number for session authentication
            host_guidance_prompt: Hotel-specific guidance for response generation
            storage_dir: Storage directory

        Returns:
            ConversationState (loaded or new)
        """
        existing = cls.load(session_id, storage_dir)
        if existing:
            return existing

        return cls(
            session_id=session_id,
            hotel_id=hotel_id,
            pms_type=pms_type,
            phone_number=phone_number,
            host_guidance_prompt=host_guidance_prompt,
            storage_dir=storage_dir
        )

    def __str__(self) -> str:
        """Human-readable representation"""
        return (
            f"ConversationState({self.metadata.session_id}): "
            f"{self.metadata.total_turns} turns, "
            f"{len(self.messages)} messages, "
            f"{len(self.tool_executions)} tool executions"
        )
